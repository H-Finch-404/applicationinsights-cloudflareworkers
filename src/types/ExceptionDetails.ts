// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// THIS FILE WAS AUTOGENERATED
import { StackFrame } from './StackFrame';
import {DataSanitizer} from '../DataSanitizer';

/**
 * Exception details of the exception in a chain.
 */
export class ExceptionDetails {

    /**
     * In case exception is nested (outer exception contains inner one), the id and outerId properties are used to represent the nesting.
     */
    public id: number;

    /**
     * The value of outerId is a reference to an element in ExceptionDetails that represents the outer exception
     */
    public outerId: number;

    /**
     * Exception type name.
     */
    public typeName: string;

    /**
     * Exception message.
     */
    public message: string;

    /**
     * Indicates if full exception stack is provided in the exception. The stack may be trimmed, such as in the case of a StackOverflow exception.
     */
    public hasFullStack: boolean;

    /**
     * Text describing the stack. Either stack or parsedStack should have a value.
     */
    public stack: string;

    /**
     * List of stack frames. Either stack or parsedStack should have a value.
     */
    public parsedStack: StackFrame[];

    constructor(exception: Error) {

        this.typeName = DataSanitizer.sanitizeString(exception.name);
        this.message = DataSanitizer.sanitizeMessage(exception.message);
        const stack = exception.stack;
        this.parsedStack = ExceptionDetails.parseStack(stack);
        this.stack = DataSanitizer.sanitizeException(stack);
        this.hasFullStack = Array.isArray(this.parsedStack) && this.parsedStack.length > 0;
    }

    private static parseStack(stack?:string): StackFrame[] {
        let parsedStack: StackFrame[];
        if (typeof stack == "string") {
            const frames = stack.split('\n');
            parsedStack = [];
            let level = 0;

            let totalSizeInBytes = 0;
            for (let i = 0; i <= frames.length; i++) {
                const frame = frames[i];
                if (StackFrame.regex.test(frame)) {
                    const parsedFrame = new StackFrame(frames[i], level++);
                    totalSizeInBytes += parsedFrame.sizeInBytes;
                    parsedStack.push(parsedFrame);
                }
            }

            // DP Constraint - exception parsed stack must be < 32KB
            // remove frames from the middle to meet the threshold
            const exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes > exceptionParsedStackThreshold) {
                let left = 0;
                let right = parsedStack.length - 1;
                let size = 0;
                let acceptedLeft = left;
                let acceptedRight = right;

                while (left < right) {
                    // check size
                    const lSize = parsedStack[left].sizeInBytes;
                    const rSize = parsedStack[right].sizeInBytes;
                    size += lSize + rSize;

                    if (size > exceptionParsedStackThreshold) {

                        // remove extra frames from the middle
                        const howMany = acceptedRight - acceptedLeft + 1;
                        parsedStack.splice(acceptedLeft, howMany);
                        break;
                    }

                    // update pointers
                    acceptedLeft = left;
                    acceptedRight = right;

                    left++;
                    right--;
                }
            }
        }

        return parsedStack;
    }
}
